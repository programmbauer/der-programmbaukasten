<!doctype html>
<html>
  <head>
    <meta charset="UTF-8"> 
    <title>T1-Lisp</title>
  </head>
  <body onload="">
    <div style="font-family: Courier; font-weight: bold">
      <h2>Welcome to T1-Lisp</h2>
      <div id="output"></div><br>
      <div>
	&gt; <input type="text" id="input" style="border: none; width:600px"><br>
	<button type="button" onclick="run();" style="border-style: solid">Eval!</button>
	<button type="button" onclick="clrscr();" style="border-style: solid">Clear</button>
				       
      </div>
    </div>
    <script>
      "use strict";

      const FEATURE_INFIX = false;//true;
      const FEATURE_STREAMS = true;
      const FEATURE_ACCOUNT = true;

      //----------------------
      // Button event handlers
      //----------------------
      function clrscr () {
	  //clears the #output area
	  document.querySelector('#output').innerHTML = '';
      }

      function run() {
	  //event handler, eval's text from the #input field
	  const output = document.querySelector('#output');
	  const input  = document.querySelector('#input');
	  output.innerHTML += "> " + input.value + "<br>";
	  let result = "";
	  try {
	      result = printExpr(readeval(input.value,globalEnv));
	  } catch(e) {
	      result = "Error: " + e;
	  }
	  output.innerHTML += result + "<br>";
	  input.value = "";
      }

      //------------------------------
      // Parsing related stuff
      //------------------------------
      function tokenize(inputString){
	  //Insert spaces before and after parentheses, then split at
	  //spaces to get a flat array of tokens
	  const withSpaces = inputString.
		replace(/\(/g, " ( ").
		replace(/\)/g, " ) ").
		replace(/\'/g, " ' ").
		replace(/\n/g, " ").
		replace(/\t/g, " ");
	  return withSpaces.split(" ").filter(string=>string.length>0);
      }

      function parseAST(tokens) {
	  //Transform the flat array from tokenize() into a
	  //hierarchical AST
	  function parseToken(token) {
	      //Parse an individual token.
	      if(token===undefined) {
		  throw "Empty input";
	      } else if(token === "(") {
		  return parseList();
	      } else if(token ==="'") {
		  return {type:"cons",
			  car: {type:"symbol", value: "quote"},
			  cdr: {type: "cons", car:parseToken(tokens.shift()), cdr: NIL}};
	      } else if  (token.match(/^-?[0-9]+$/) != null) {
		  return {type: "number", value: parseInt(token)};
	      } else if (token.match(/^[a-zA-Z0-9\+\-\*\#\?\<\>\!\&\=]+$/) != null) {
		  return {type: "symbol", value: token};
	      } else {
		  throw "Invalid token: " + token;
	      }
	  }
	
	  function parseList() {
	      //Read tokens until the end of a list and return them as
	      //an array.  With the recursive calls and the global
	      //token stream this is enough to parse nested list
	      //structures
	      let list = NIL;
	      while(true) {
		  token = tokens.shift();
		  if(token === undefined) {
		      throw "Missing ')'";
		  } else if (token === ")") {
		      return list;
		  } else {
		      list = append(list, parseToken(token));
		  }
	      }
	  }
  	  let token = 0;
	  let ast = NIL;
	  token = tokens.shift();
	  if(token === "(") {
	      ast = parseList();
	  } else {
	      ast = parseToken(token);
	  }
	  return ast;
      }

      //----------------------
      // Cons helper functions
      //----------------------
      function append(list, element) {
	  //Appends a given element to a cons-list
	  let help = list;
	  if(list === NIL) {
	      return {type: "cons", car: element, cdr: NIL};
	  } else {
	      while(help.cdr != NIL) {
		  if(help.type != "cons") {
		      console.log(help);
		      throw "Append expected a proper list, but found a " + help.type;
		  }
		  help = help.cdr;
	      }
	      help.cdr = {type: "cons", car: element, cdr: NIL};
	      return list;
	  }
      }

      function* generateCons(cons) {
	  //Yields each element of a cons-list. Improper lists are
	  //supported by a hack.
	  if(cons === NIL) {
	      return cons;
	  } else if (cons.type != "cons") {
	      throw "generateCons expected a cons cell, but found a " + cons.type;
	  } else {
	      while(cons.type === "cons") {
		  yield cons.car;
		  cons = cons.cdr;
	      }
	      if(cons != NIL) {
		  yield cons;
	      }
	  }
      }

      function lengthCons(cons) {
	  //Returns the length of a cons-list.
	  let n = 0;
	  while(true) {
	      if(cons === NIL) {
		  return n;
	      } else if (cons.type === "cons") {
		  n = n + 1;
		  cons = cons.cdr;
	      } else {
		  throw "lengthCons: not a proper list: " + cons.type;
	      }
	  }
      }

      function nthCons(cons, n) {
	  //Gets the nth value from a list, starting with element 0.
	  while(true) {
	      if(n <= 0) {
		  return cons.car;
	      }
	      n = n - 1;
	      cons = cons.cdr;
	  }
      }
      
      //-------------
      // Eval & Apply
      //-------------

      function lispeval (ast,env) {
	  //Evaluatest the expression ast (as computed by parseAST) in
	  //the environment env. WARNING! Should only be called via
	  //trampoline(["eval",ast,env]);

	  //console.log("DEBUG: lispeval");
	  //console.log(ast);
	  //console.log(env);
	  if(ast.type === "cons") {
	      if (ast.car.value === "define") {
		  //this takes care of McCarthy's LABEL rule, as a define'd procedure is
		  //executed in an environment where it's already bound. Much more SICP style.
		  if (ast.cdr.car.type === "symbol") {
		      env[ast.cdr.car.value] = trampoline(["eval",ast.cdr.cdr.car,env]);
		  } else if (ast.cdr.car.type === "cons") {
		      let spec = ast.cdr.car;
		      let body = ast.cdr.cdr;
		      env[spec.car.value] = {type: "lambda", args: spec.cdr, env: makeEnv(env), body: body};
		  } else {
		      throw "Define expected a symbol or a cons (i.e. function spec), found " + printExpr(ast.cdr.car);
		  }
		  return ["value",env.__get(ast.cdr.car.value)];
	      } else if (ast.car.value === "set!") {
		  //this takes care of McCarthy's LABEL rule, as a define'd procedure is
		  //executed in an environment where it's already bound. Much more SICP style.
		  if (ast.cdr.car.type === "symbol") {
		      let targetEnv = env;
		      let found = false;
		      while (targetEnv != null) {
			  if(targetEnv.__get(ast.cdr.car.value,false) != undefined) {
			      found = true;
			      targetEnv[ast.cdr.car.value] = trampoline(["eval",ast.cdr.cdr.car,env]);
			      return ["value",env.__get(ast.cdr.car.value)];
			  } else {
			      targetEnv = targetEnv.__parent;
			  }
		      }
		      //not found
		      throw "Unknown identifier: " + ast.cdr.car.value;
		      //permissive variant: env[ast.cdr.car.value] = trampoline(["eval",ast.cdr.cdr.car,env]);
		  } else {
		      throw "Set! expected a symbol, found " + printExpr(ast.cdr.car);
		  }
		  return ["value",env.__get(ast.cdr.car.value)];
	      } else if (ast.car.value === "primitive-plus") {
		  let a = trampoline(["eval",ast.cdr.car, env]);
		  let b = trampoline(["eval",ast.cdr.cdr.car, env]);
		  if (a.type != "number") {
		      throw "Cannot add: " + printExpr(a);
		  }
		  if (b.type != "number") {
		      throw "Cannot add: " + printExpr(b);
		  }
		  let result = a.value+b.value;
		  return ["value", {type: "number", value: result}];
	      } else if (ast.car.value === "primitive-minus") {
		  let a = trampoline(["eval",ast.cdr.car, env]);
		  let b = trampoline(["eval",ast.cdr.cdr.car, env]);
		  if (a.type != "number") {
		      throw "Cannot subtract: " + printExpr(a);
		  }
		  if (b.type != "number") {
		      throw "Cannot subtract: " + printExpr(b);
		  }
		  let result = a.value-b.value;
		  return ["value", {type: "number", value: result}];
	      } else if (ast.car.value === "primitive-less-than") {
		  let x = trampoline(["eval",ast.cdr.car, env]).value;
		  let y = trampoline(["eval",ast.cdr.cdr.car, env]).value;
		  if (x != undefined && y != undefined) {
		      if(x < y) {
			  return ["value", _T];
		      } else {
			  return ["value", _F];
		      }
		  } else {
		      throw "Cannot compare " + x + " and " + y;
		  }
	      } else if (ast.car.value === "quote") {
		  if(ast.cdr.cdr != NIL) {
		      throw "Quote expects a single argument. Maybe use a list, e.g. (quote (a b c))?";
		  }
		  return ["value", ast.cdr.car];
	      } else if (ast.car.value === "primitive-car") {
		  let obj = trampoline(["eval",ast.cdr.car, env]);
		  if (obj === undefined) {
		      throw "Undefined object: " + printExpr(ast.cdr.car);
		  }
		  if(obj.type === "cons") {
		      return ["value", obj.car];
		  } else {
		      throw "Car expected a cons cell, found " + printExpr(obj);
		  }
	      } else if (ast.car.value === "primitive-cdr") {
		  let obj = trampoline(["eval",ast.cdr.car, env]);
		  if (obj === undefined) {
		      throw "Undefined object: " + printExpr(ast.cdr.car);
		  }
		  if(obj.type === "cons") {
		      return ["value", obj.cdr];
		  } else {
		      throw "Cdr expected a cons cell, found " + obj;
		  }
	      } else if (ast.car.value === "primitive-cons") {
		  return ["value", {type: "cons", car: trampoline(["eval",ast.cdr.car,env]), cdr: trampoline(["eval",ast.cdr.cdr.car,env])}];
	      } else if (ast.car.value === "primitive-equal?") {
		  let x = trampoline(["eval",ast.cdr.car,env]);
		  let y = trampoline(["eval",ast.cdr.cdr.car,env]);
		  if(equal(x,y,env)) {
		      return ["value", _T];
		  } else {
		      return ["value", _F];
		  }
	      } else if (ast.car.value === "primitive-atom?") {
		  if (trampoline(["eval",ast.cdr.car, env]).type === "cons") {
		      return ["value", _F];
		  } else {
		      return ["value", _T];
		  }
	      } else if (ast.car.value === "primitive-apply") {
		  let fun = trampoline(["eval",ast.cdr.car,env]);
		  let args = env.__get(ast.cdr.cdr.car.value);
		  return ["apply",fun,args,env, ast.cdr.cdr.car.value];
	      } else if (ast.car.value === "cond") {
		  for(let clause of generateCons(ast.cdr)) {
		      let condition = trampoline(["eval",clause.car, env]);
		      if(condition.value != "#f") {
			  return ["eval",clause.cdr.car,env];
			  break;
		      }
		  }
		  return ["value", NIL];
	      } else if (ast.car.value === "lambda") {
		  return ["value", {type: "lambda", args: ast.cdr.car, env: makeEnv(env), body: ast.cdr.cdr}];
	      } else if (ast.car.value === "macro") {
		  return ["value", {type: "macro",  args: ast.cdr.car, env: makeEnv(env), body: ast.cdr.cdr}];
	      } else if (ast.car.value === "error") {
		  throw printExpr(ast.cdr);
	      } else {
		  //--------------------
		  //Function application
		  //--------------------
		  let fun = trampoline(["eval",ast.car, env]);
		  if(fun === undefined) {
		      throw "unknown function: " + ast.car.value;
		  }
		  //console.log("DEBUG: eval(function)");
		  //console.log(fun);

		  //The following code allows for numbers as functions.
		  //Functions apply their first arg to (cons <themself> <& following args>).
		  //Thus, (fully parenthesized) infix arithmetic can be used. This is inspired by The history of Lisp [??] section ?? //TODO: add source
		  //This feature can be turned off by setting FEATURE_INFIX to false.
		  if(FEATURE_INFIX && fun.type === "number") {
		      let args = NIL;
		      let newfun = trampoline(["eval",ast.cdr.car, env]);
		      if(newfun.type != "lambda" && newfun.type != "macro") {
			  throw "Numbers cannot receive messages of type: " + newfun.type;
		      }
		      for (let arg of generateCons(ast.cdr.cdr)) {
			  args = append(args,trampoline(["eval",arg,env]));
		      }
		      return ["apply",newfun,{type: "cons", car: fun, cdr: args}, env, "Actor message " + printExpr(newfun)];
		  }

		  //new feature "macros"
		  if (fun.type === "macro") {
		      let args = NIL;
		      for (let arg of generateCons(ast.cdr)) {
			  args = append(args,arg); //<-- difference #1
		      }
		      return ["apply",fun, args, env, "macro " + ast.car.value];
		  }
		  //end "macros"
		  //assume fun to be a lambda, let apply deal with errors
		  if (fun.type === "lambda") {

		      let args = NIL;
		      for (let arg of generateCons(ast.cdr)) {
			  args = append(args,trampoline(["eval",arg,env]));
		      }
		      return ["apply",fun, args, env, ast.car.value];
		  }
		  throw "Cannot apply type " + fun.type
	      }
	  } else {
	      //-------------------------
	      //The expression is an atom
	      //-------------------------
	      if (ast.type === "number") {
		  return ["value", ast];
	      } else if (ast.type === "symbol") {
		  let astValue = env.__get(ast.value);
		  if (astValue === undefined) {
		      throw "Unknown symbol: " + printExpr(ast);
		  }
		  return ["value", astValue];
	      } else {
		  throw "Illegal type: " + ast;
	      }
	  }
      }

      function trampoline(packedArgs) {
	  //Trampoline calls eval and apply again and again. Both
	  //functions either return an actual return value, or
	  //information that tells trampoline which function needs to
	  //be called next. This turns tail recursion into iteration.
	  
	  while(true) {
	      if(packedArgs[0] === "value") {
		  return packedArgs[1];
	      } else if (packedArgs[0] === "eval") {
		  packedArgs = lispeval(packedArgs[1],packedArgs[2]);
	      } else if (packedArgs[0] === "apply") {
		  packedArgs = lispapply(packedArgs[1],packedArgs[2],packedArgs[3],packedArgs[4]);
	      } else {
		  throw "illegal return value " + packedArgs +" // "+ printExpr(packedArgs);
	      }
	  }
      }

      function lispapply(fun,args,env,name) {
	  //Applies the function fun to the arguments in args in the
	  //environment env. A function name can be supplied for
	  //better error messages.

	  //Check numer of arguments. Ignore this, if a &rest argument is used
	  if(lengthCons(args) != lengthCons(fun.args) && nthCons(fun.args, lengthCons(fun.args)-1).value != "&rest") {
	      throw "Wrong number of arguments in "+ name +
		  ". expected " + lengthCons(fun.args) + " got " + lengthCons(args);
	  }

	  //Make a new environment for the function.
	  let funEnv = makeEnv(fun.env);

	  //The magic code that makes macros evaluate their arguments
	  //on read.
	  if(fun.type === "macro") {
	      funEnv["__get"] = function(val,checkparent = true) { //<-- difference #2
		  if(funEnv[val] != undefined) {
		      return trampoline(["eval",funEnv[val],env]);
		  } else if (funEnv["__parent"] && checkparent) {
		      return funEnv["__parent"].__get(val);
		  } else {
		      //throw "Apply: Undefined value: " + val;
		  }
	      }
	  }
	  
	  //Put the arguments in the new environment. The arguments
	  //have already been evaluated in eval (or not, in the case
	  //of a macro).
	  let argshelper = fun.args;
	  while(argshelper != NIL) {
	      if(argshelper.car.type === "symbol" && argshelper.car.value === "&rest") {
		  if(fun.type === "macro") {
		      funEnv[argshelper.car.value] = {type:"cons", car: {type:"symbol",value:"list"}, cdr: args};
		  } else {
		      funEnv[argshelper.car.value] = args;
		  }
		  break;
	      }
	      funEnv[argshelper.car.value] = args.car;
	      args = args.cdr;
	      argshelper = argshelper.cdr;
	  }
	  let result = NIL;

	  //Execute each instruction in the functions body. Return
	  //before executing the last instruction to enable tail
	  //recursion via trampoline.
	  let listwalker = fun.body;
	  if(listwalker === NIL) { return ["value",NIL];}
	  while(true) {
	      if(listwalker.cdr === NIL) {
		  return ["eval", listwalker.car, funEnv];
	      } else {
  		  result = trampoline(["eval",listwalker.car,funEnv]);
		  listwalker = listwalker.cdr;
	      }
	  }	  
      }

      //----------------------------------
      // Helper functions for eval & apply
      //----------------------------------
      function makeEnv (parent) {
	  //Create a new environment which will later contain bindings
	  //(variable->value). Get a value from the environment env by
	  //calling env.get(variable). If a value is not found, the
	  //parent environments are checked recursively. WARNING:
	  //Macros hack this implementation in lispapply.
	  
	  let env = {__parent: parent};
	  env["__get"] = function(val, checkparent=true) {
	      if(env[val] != undefined) {
		  return env[val];
	      } else if (env["__parent"] && checkparent) {
		  return env["__parent"].__get(val);
	      } else {
		  //throw "MakeEnv: Undefined value: " + val;
	      }
	  }
	  return env;
      }

      function equal(x,y) {
	  if(x.type === "lambda" || x.type === "lambda") {
	      throw "don't compare lambdas";
	  }
	  if(x.type === "cons") {
	      return y.type === "cons" &&
		  equal(x.car,y.car) &&
		  equal(x.cdr,y.cdr);
	  } else {
	      return x.type === y.type && x.value === y.value;
	  }
      }

      //---------------
      // REPL functions
      //---------------
      function readeval (expr, env) {
	  //Convert a textual lisp program into an ast and eval it.
	  let result =  trampoline(["eval",parseAST(tokenize(expr),[]),env]);
	  return result;
      }

      function printExpr(expr) {
	  //Prints (i.e. returns as a string) a lisp expression in
	  //human readable form.
	  if(expr === undefined) {
	      return "&lt;no value&gt;";
	  }
	  if(expr.type == "cons") {
	      let result = "( ";
	      for(let element of generateCons(expr)) {
		  result += printExpr(element) + " ";
	      }
	      return result + ")";	      
	  } else if(expr.type === "lambda"){
	      let body = printExpr(expr.body);
	      return "(lambda " + printExpr(expr.args) + " " + body.substr(1,body.length-2) + ")";
	  } else if(expr.type === "macro"){
	      let body = printExpr(expr.body);
	      return "(macro " + printExpr(expr.args) + " " + body.substr(1,body.length-2) + ")";
	  } else if (expr.value != undefined){
	      return expr.value;
	  } else {
	      throw "Don't know how to print " + expr;
	  }
      }

      //-------------------------------
      // Global Environment & Constants
      //-------------------------------
      let globalEnv = makeEnv(null);
      //These constants should never be changed. But if you want to
      //(define #f #t), feel free to try it...
      globalEnv["#t"] = {type: "symbol", value: "#t"};
      globalEnv["#f"] = {type: "symbol", value: "#f"};
      globalEnv["()"] = {type: "symbol", value: "()"};
      globalEnv["lambda"] = {type: "symbol", value: "lambda"};
      //globalEnv["quote"] = {type: "symbol", value: "quote"};//probably unneccessary
      //Constants to make the javascript code less ugly
      const _T = globalEnv.__get("#t");
      const _F = globalEnv.__get("#f");
      const NIL = globalEnv.__get("()");
      
      //---------------------
      // Predefined functions
      //---------------------
      //The basic interpreter is ready to run now.
      //Time to bootstrap a usable environment.
      //template for copy&paste: readeval("(define )",globalEnv);

      //lisp wrappers for all appropriate primitives
      readeval("(define (+ &rest) (cond ((equal? () &rest) 0) (#t (primitive-plus (car &rest) (apply + (cdr &rest))))))",globalEnv);
      readeval("(define (- &rest) (cond ((equal? () &rest) 0) (#t (primitive-minus (car &rest) (apply - (cdr &rest))))))",globalEnv);
      readeval("(define (< a b) (primitive-less-than a b))",globalEnv);
      readeval("(define (cons a b) (primitive-cons a b))",globalEnv);
      readeval("(define (car a) (primitive-car a))",globalEnv);
      readeval("(define (cdr a) (primitive-cdr a))",globalEnv);
      readeval("(define (atom? a) (primitive-atom? a))",globalEnv);
      readeval("(define (apply fun args) (primitive-apply fun args))",globalEnv);
      readeval("(define (equal? a b) (primitive-equal? a b))",globalEnv);

      //some macros
      readeval("(define if (macro (i t e) (cond (i t) (#t e))))",globalEnv);
      readeval("(define and (macro (p q) (cond (p q) (#t #f))))",globalEnv);
      readeval("(define or (macro (p q) (cond (p p) (#t q))))",globalEnv);
      readeval("(define (begin &rest) (if (null? &rest) () (if (null? (cdr &rest)) (car &rest) (apply begin (cdr &rest)))))",globalEnv);//depends on the arguments being evaluated in order
      
      //misc. functions
      readeval("(define = equal?)",globalEnv);
      readeval("(define (> x y) (< y x))",globalEnv);
      readeval("(define (>= x y) (or (> x y) (equal? x y)))",globalEnv);
      readeval("(define (<= x y) (or (< x y) (equal? x y)))",globalEnv);
      readeval("(define (* x y) (cond ((equal? y 0) 0) ((< y 1) (* (- 0 x) (- 0 y))) (#t (+ x (* x (- y 1))))))",globalEnv);
      readeval("(define (mod x y) (cond ((equal? x y) 0) ((< x y) x) (#t (mod (- x y) y))))",globalEnv);
      readeval("(define remainder mod)",globalEnv); //TODO: Which name should I keep? or modulo? What about div vs quotient?
      readeval("(define (div x y) (define (divhelp x y acc) (cond ((equal? y 0) (error div -- Division by zero)) ((< y 0) (error div -- Only positive values for y are supported)) ((< x y)  acc) " +
	       "((>= x y) (divhelp (- x y) y (+ acc 1))))) (divhelp x y 0))",globalEnv);
      readeval("(define (list &rest) &rest)",globalEnv);
      readeval("(define (map f l) (cond ((equal? l ()) ()) (#t (cons (f (car l)) (map f (cdr l))))))", globalEnv);
      readeval("(define (reduce f l init) (cond ((equal? l ()) init) (#t (reduce f (cdr l) (f init (car l))))))", globalEnv);
      readeval("(define (null? l) (equal? l ()))",globalEnv);
      readeval("(define (even? x) (= (mod x 2) 0)))",globalEnv);
      readeval("(define (not x) (if (= x #f) #t #f))",globalEnv);

      if(FEATURE_STREAMS) {
	  //Streams and delayed evaluationfrom SICP chapter 3. This
	  //feature can be turned off by setting FEATURE_STREAMS to
	  //false. WARNING: This contains some commonly used scheme
	  //functions/macros, like delay.
	  readeval("(define delay (macro (exp) (lambda () exp)))",globalEnv);
	  readeval("(define cons-stream (macro (a b) (cons a (delay b))))",globalEnv);
	  readeval("(define (force delayed-object) (delayed-object))",globalEnv);
	  readeval("(define (stream-car stream) (car stream))",globalEnv);
	  readeval("(define (stream-cdr stream) (force (cdr stream)))",globalEnv);
	  readeval("(define the-empty-stream ())",globalEnv);
	  readeval("(define stream-null? null?)",globalEnv);
	  readeval("(define (stream-ref s n) (if (= n 0) (stream-car s) (stream-ref (stream-cdr s) (- n 1))))",globalEnv);
	  readeval("(define (stream-map proc s) (if (stream-null? s) the-empty-stream (cons-stream (proc (stream-car s)) (stream-map proc (stream-cdr s)))))",globalEnv);
	  readeval("(define (stream-for-each proc s)  (if (stream-null? s) (quote done) (begin (proc (stream-car s)) (stream-for-each proc (stream-cdr s)))))",globalEnv);
	  //skipped display-stream and display-line for now; need to implement display etc.
	  readeval("(define (stream-enumerate-interval low high) (if (> low high) the-empty-stream (cons-stream low (stream-enumerate-interval (+ low 1) high))))",globalEnv);
	  readeval("(define (stream-filter pred stream) (cond ((stream-null? stream) the-empty-stream) ((pred (stream-car stream)) (cons-stream (stream-car stream)"+
		   "(stream-filter pred (stream-cdr stream)))) (#t (stream-filter pred (stream-cdr stream)))))",globalEnv); //replaced else with #t, //TODO: add else to cond
	  //TODO: Why does this example fail? (stream-car (stream-cdr (stream-filter even? (stream-enumerate-interval 10000 1000000)))) // ANSWER: Because of the recursion in mod -.-
	  //skipped memo-proc, need to implement set!
	  //skipped stuff
	  readeval("(define (integers-starting-from n) (cons-stream n (integers-starting-from (+ n 1))))",globalEnv);
	  readeval("(define integers (integers-starting-from 1))",globalEnv);
	  readeval("(define (divisible? x y) (= (remainder x y) 0))",globalEnv);
	  readeval("(define no-sevens (stream-filter (lambda (x) (not (divisible? x 7))) integers))",globalEnv);
	  readeval("(define (sieve stream) (cons-stream (stream-car stream) (sieve (stream-filter (lambda (x) (not (divisible? x (stream-car stream)))) (stream-cdr stream)))))",globalEnv);
	  readeval("(define primes (sieve (integers-starting-from 2)))",globalEnv);
      }

      if(FEATURE_ACCOUNT) {
	  //changed ' to quote, eq? to equal, else to #t, crippeld the error message due to missing backquote support. I should import this again once these features are added.
	  readeval("(define (make-account balance)"+
		   "  (define (withdraw amount) (if (>= balance amount) (begin (set! balance (- balance amount)) balance) 'Insufficient-funds))"+
		   "  (define (deposit amount) (set! balance (+ balance amount)) balance)"+
		   "  (define (dispatch m) (cond ((equal? m 'withdraw) withdraw) ((equal? m 'deposit) deposit) "+
		   "    (#t (error Unknown request -- MAKE-ACCOUNT))))  dispatch)",globalEnv);
      }
      
      //------------------------
      // Tests and related stuff
      //------------------------
      function _test (expr, expected) {
	  //Check if expr evaluates to expected. Log the result on the
	  //console.
	  let testresult = null;
	  let expectedresult = null;
	  let error = "";
	  try {
	      testresult =  readeval(expr, globalEnv);
	      expectedresult = readeval(expected, globalEnv);
	  } catch(e) {
	      error = e;
	  }
	  let message = "???";
	  if(error != "") {
	      message = "!! // Got an error: " + error;
	  } else if(equal(testresult,expectedresult)) {
	      message = "OK // " + expr + " => " +  printExpr(testresult);
	  } else {
	      message = "!! //expected: " + printExpr(expectedresult)  + " found: " +  printExpr(testresult);
	  }
	  console.log(message);
      }

      
      function testCases() {
	  //This function contains misc. regression tests collected
	  //during development.

	  _test("#t",trampoline(["eval",readeval("#t",globalEnv),globalEnv]).value); //self-evaluation
	  _test("(car (cdr (cons 1 (cons 2 (cons 3 4)))))", "2");
	  readeval("(define x 3)",globalEnv);
	  _test ("(+ x (+ x 4))", "10");
	  _test("(equal? (cons 1 (+ 1 2)) (cons (+ 0 1) 3))", "#t");
	  _test("(cond ((equal? 1 2) #f)((equal? 1 1) #t))", "#t");
	  _test("(((lambda (x) (lambda (y) (+ x y))) 6) 5)", "11");
	  readeval("(define (times-2 x) (+ x x))",globalEnv);
	  _test("(times-2 3)", "6");
 	  readeval("(define (cadr x) (car (cdr x)))",globalEnv);
	  _test("(cadr (cons 1 (cons 2 ())))","2");
	  readeval("(define (sum x) (if (equal? x 0) 0 (+ x (sum (- x 1)))))",globalEnv); //recursion
	  _test("(sum 15)", "120");
	  _test("(* 100 100)", "10000"); //using predefined scheme functions
	  _test("(div 250 25)", "10");
	  readeval("(define (fib n) (cond ((< n 2) n) (#t (+ (fib (- n 1)) (fib (- n 2))))))",globalEnv); //recursive fibonacci:
	  _test("(fib 7)","13");
	  _test("(equal? (quote (a b c)) (quote (a b c)))","#t");
	  _test("(equal? (quote (a b c)) (quote (a b)))","#f");
	  _test("(equal? (map fib (quote (1 2 3))) (quote (1 1 2)))","#t");//yay, quote works
	  //The Big One. Factorial using the "poor man's y combinator (W. Byrd):
	  _test("(((lambda (!) (lambda (n) ((! !) n))) (lambda (!) (lambda (n) (cond ((equal? n 0) 1) (#t (* n ((! !) (- n 1)))))))) 5)","120");
	  _test("(map atom? (quote (1 (2 3) hi (bye))))","(list #t #f #t #f)");
	  _test("(reduce + (list 1 2 3 4 5) 0)","15");
	  _test("(if #t 1 (div 1 0))","1"); //this would produce an error without macros
	  _test("(stream-ref no-sevens 100)","117");
	  _test("(((make-account 100) 'withdraw) 50)","50");


	  //-----------------------------
	  //Longer-running tests below!!!
	  //-----------------------------
	  _test("(stream-ref primes 50)","233");
	  //test tail recursion
	  _test("(stream-car (stream-cdr (stream-filter even? (stream-enumerate-interval 10000 1000000))))","10002");
	  _test("(div 100000 2)","50000");
      }

    </script>
  </body>
</html>

<!--
TODO:
Bugs / Missing features:
- [X] +, -, < can't be used in higher-order functions. Define + as a function and use primitive-plus as special form?
  - [X] However, this makes variadic + impossible right now. Implement variadic functions?
- [X] quote is broken?
- [X] define <=, >=, and, or, if, ...
  - [X] Macros?
- [X] printExpr doesn't handle lambda yet (fixed to remove () around body)
- [X] function application mutates a lambda's environment permanently
- [?] improve UI
- [X] use cons instead of array
- [X] Tail Call Elimination (BAM, done!!!)
  -[ ] => implement queue of unevaluated lisp expressions, turn js-recursion into loop
- [X] fix equal? for quote and lambda. and fix it again. fix quote.
- [X] add (map f l)
- [X] begin
- [ ] let

Bonus-features
- [X] (list ...), 
- [X] print conses as lists
- [X] 'quote
- unquote, splicing
- [X] Numbers as functions?
- js-eval?
- Strings?
- macros & definitions from Lisp Micro Manual
- make memory-management explicit by using a stack of environments? 
  (bad idea, because new environments could use any existing one as their parent,
   so this means fullblown garbage-collection)
- set! to change value in env higher up the chain
- display, ...

/////////////////////////////////////////////////////
// What's still missing for an R4RS-compliant Scheme?
/////////////////////////////////////////////////////
easy, symbolic:
- type predicates (pair?, list?, boolean?, char?,string?, number?, procedure?, ...)
- begin (mit lambda, aber environment beachten)
- cddadr etc.
- length, append, reverse, list-tail (aka drop, definition ist in r4rs), list-ref
- memq, memv, member (trivial, wenn die eq-prädikate passen)
- assq, assv, assoc

easy, numbers:
- number predicates (exact?, odd?, zero?, ...)
- min, max (variadic) , abs
- gcd, lcm
- floor, ceiling, round, truncate
- exp, log, sin, ... (wenn reals implementiert sind)

probably relatively easy:
- strings, symbol->string, string-symbol
- better number types (rationals, reals, complex)
- set!
- else in cond
- and/or variadic
- case 
- let, letrec, let*
- do
- eqv, eq
- set-car!, set-cdr!
- vectors (r4rs section 6.8)
- eval, apply
- map variadic, for-each

probably difficult:
- quote syntax
- quasiquote
- dotted pairs
- call/cc
- input/output-ports
- system interface



-->
