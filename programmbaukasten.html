<!doctype html>
<html>
  <head>
    <meta charset="UTF-8"> 
    <title>T1-Lisp</title>
  </head>
  <body onload="">
    <div style="font-family: Courier; font-weight: bold">
      <h2>Welcome to T1-Lisp</h2>
      <div id="output"></div><br>
      <div>
	&gt; <input type="text" id="input" style="border: none; width:300px"></input><br>
	<button type="button" onclick="run();" style="border-style: solid">Eval!</button>
	<button type="button" onclick="clrscr();" style="border-style: solid">Clear</button>
				       
      </div>
    </div>
    <script>
      "use strict";

      function clrscr () {
	  //clears the #output area
	  document.querySelector('#output').innerHTML = '';
      }

      function run() {
	  //event handler, eval's text from the #input field
	  const output = document.querySelector('#output');
	  const input  = document.querySelector('#input');
	  output.innerHTML += "> " + input.value + "<br>";
	  let result = "";
	  try {
	      result = printExpr(readeval(input.value,globalEnv));
	  } catch(e) {
	      result = "Error: " + e;
	  }
	  output.innerHTML += result + "<br>";
	  input.value = "";
      }

      function tokenize(inputString){
	  //insert spaces before and after parentheses, then split at spaces
	  //to get a flat array of tokens
	  const withSpaces = inputString.
		replace(/\(/g, " ( ").
		replace(/\)/g, " ) ").
		replace(/\n/g, " ").
		replace(/\t/g, " ");
	  return withSpaces.split(" ").filter(string=>string.length>0);
      }

      function parseAST(tokens) {
	  //transform the flat array from tokenize() into a hierarchical AST
	  function parseToken(token) {
	      if(token===undefined) {
		  throw "Empty input";
	      } else if(token === "(") {
		  return parseList();
	      } else if  (token.match(/^[0-9]+$/) != null) {
		  return {type: "number", value: parseInt(token)};
	      } else if (token.match(/^[a-zA-Z0-9\+\-\*\#\?\<\>]+$/) != null) {
		  return {type: "symbol", value: token};
	      } else {
		  throw "Error: no matching case found for " + token;
	      }
	  }
	  function append(list, element) {
	      let help = list;
	      if(list === globalEnv["()"]) {
		  return {type: "cons", car: element, cdr: globalEnv["()"]};
	      } else {
		  while(help.cdr != globalEnv["()"]) {
		      if(help.type != "cons") {
			  console.log(help);
			  throw "append: not a proper List " + help.type;
		      }
		      help = help.cdr;
		  }
		  help.cdr = {type: "cons", car: element, cdr: globalEnv["()"]};
		  return list;
	      }
	  }
	  function parseList() {
	      let list = globalEnv["()"];
	      while(true) {
		  token = tokens.shift();
		  if(token === undefined) {
		      throw "Error: Missing ')'";
		  } else if (token === ")") {
		      return list;
		  } else {
		      list = append(list, parseToken(token));
		  }
	      }
	  }
  	  let token = 0;
	  let ast = globalEnv["()"];
	  token = tokens.shift();
	  if(token === "(") {
	      ast = parseList();
	  } else {
	      ast = parseToken(token);
	  }
	  return ast;
      }


      function* generateCons(cons) {
	  if(cons === globalEnv["()"]) {
	      return cons;
	  } else if (cons.type != "cons") {
	      throw "generateCons expected cons, found" + cons.type;
	  } else {
	      while(cons.type === "cons") {
		  yield cons.car;
		  cons = cons.cdr;
	      }
	  }
      }

      function lengthCons(cons) {
	  let n = 0;
	  while(true) {
	      if(cons === globalEnv["()"]) {
		  return n;
	      } else if (cons.type === "cons") {
		  n = n + 1;
		  cons = cons.cdr;
	      } else {
		  throw "lengthCons: not a proper list: " + cons.type;
	      }
	  }
      }

      function nthCons(cons, n) {
	  //gets the nth value from a list, starting with element 0.
	  while(true) {
	      if(n <= 0) {
		  return cons.car;
	      }
	      n = n - 1;
	      cons = cons.cdr;
	  }
      }
      
      function lispeval (ast,env) {
	  //evaluatest the expression ast (as computed by parseAST) in the environment env

	  //console.log("DEBUG: lispeval");
	  //console.log(ast);
	  //console.log(env);
	  if(ast.type === "cons") {
	      if (ast.car.value === "define") {
		  //this takes care of McCarthy's LABEL rule, as a define'd procedure is
		  //executed in an environment where it's already bound. Much more SICP style.
		  if (ast.cdr.car.type === "symbol") {
		      env[ast.cdr.car.value] = lispeval(ast.cdr.cdr.car,env);
		  } else if (ast.cdr.car.type === "cons") {
		      let spec = ast.cdr.car;
		      let body = ast.cdr.cdr;
		      env[spec.car.value] = {type: "lambda", args: spec.cdr, env: {__parent : env}, body: body};
		  } else {
		      throw "Error: define expected a symbol or a cons (i.e. function spec), found" + ast.cdr.car;
		  }
	      } else if (ast.car.value === "+") {
		  let result = 0;
		  for(let element of generateCons(ast.cdr)) {
		      let obj = lispeval(element, env);
		      if (obj.type == "number") {
			  result += obj.value;
		      } else {
			  throw "Cannot add: " + obj;
		      }
		  }
		  return {type: "number", value: result};
	      } else if (ast.car.value === "-") {
		  let result = lispeval(ast.cdr.car,env).value;
		  for(let element of generateCons(ast.cdr.cdr)) {
		      let obj = lispeval(element, env);
		      if (obj.type == "number") {
			  result -= obj.value;
		      } else {
			  throw "Cannot add: " + obj;
		      }
		  }
		  return {type: "number", value: result};
	      } else if (ast.car.value === "<") {
		  let x = lispeval(ast.cdr.car, env).value;
		  let y = lispeval(ast.cdr.cdr.car, env).value;
		  if (x != undefined && y != undefined) {
		      if(x < y) {
			  return(globalEnv["#t"]);
		      } else {
			  return(globalEnv["#f"]);
		      }
		  } else {
		      throw "cannot compare " + x + " and " + y;
		  }
	      } else if (ast.car.value === "quote") {
		  return ast;
	      } else if (ast.car.value === "car") {
		  let obj = lispeval(ast.cdr.car, env);
		  if(obj.type === "cons") {
		      return obj.car;
		  } else {
		      throw "Not a cons cell: " + obj;
		  }
	      } else if (ast.car.value === "cdr") {
		  let obj = lispeval(ast.cdr.car, env);
		  if(obj.type === "cons") {
		      return obj.cdr;
		  } else {
		      throw "Not a cons cell: " + obj;
		  }
	      } else if (ast.car.value === "cons") {
		  return {type: "cons", car: lispeval(ast.cdr.car,env), cdr: lispeval(ast.cdr.cdr.car,env)};
	      } else if (ast.car.value === "equal?") {
		  if(equal(ast.cdr.car,ast.cdr.cdr.car, env)) {
		      return globalEnv["#t"];
		  } else {
		      return globalEnv["#f"];
		  }
	      } else if (ast.car.value === "atom?") {
		  if (lispeval(ast.cdr.car, env).type === "cons") {
		      return globalEnv["#f"];
		  } else {
		      return globalEnv["#t"];
		  }
	      } else if (ast.car.value === "cond") {
		  for(let clause of generateCons(ast.cdr)) {
		      let condition = lispeval(clause.car, env);
		      if(condition.value != "#f") {
			  return lispeval(clause.cdr.car,env);
			  break;
		      }
		  }
		  return globalEnv["()"];
	      } else if (ast.car.value === "lambda") {
		  return {type: "lambda", args: ast.cdr.car, env: {__parent : env}, body: ast.cdr.cdr};
	      } else {
		  //Function application
		  let fun = lispeval(ast.car, env);
		  if(fun === undefined) {
		      throw "unknown function: " + ast.car.value;
		  }
		  //console.log("DEBUG: eval(function)");
		  //console.log(fun);
		  let args = [];
		  for (let arg of generateCons(ast.cdr)) {
		      args.push(lispeval(arg,env));
		  }
		  if(fun.type != "lambda") {
		      throw "cannot apply: " + fun.type + " " + fun.value;
		  }
		  if(args.length != lengthCons(fun.args)) {
		      throw "wrong number of arguments. expected " +
			  fun.args.length + " got " + args.length;
		  }
		  for(let i = 0; i < args.length; i++) {
		      fun.env[nthCons(fun.args,i).value] = args[i];
		  }
		  let result = globalEnv["()"];
		  for(let expr of generateCons(fun.body)){
		      result = lispeval(expr,fun.env);
		  }
		  return result;
	      }
	  } else {
	      //the expression is an atom
	      if (ast.type === "number") {
		  return ast;
	      } else if (ast.type === "symbol") {
		  let astValue = getVal(ast.value,env);
		      return astValue;
	      } else {
		  throw "illegal type: " + ast;
	      }
	  }
      }

      function getVal(val,env) {
	  //console.log("DEBUG: getVal");
	  //console.log(val);
	  //console.log(env);
	  if(env[val] != undefined) {
	      return env[val];
	  } else if (env["__parent"]) {
	      return getVal(val,env["__parent"]);
	  } else {
	      "Undefined value: " + val;
	  }
      }

      function equal(quotex,quotey, env) {
	  //checks if quotex and quotey evaluate to the same value
	  let x = lispeval(quotex,env);
	  let y = lispeval(quotey,env);
	  if(x.type === "cons") {
	      return equal(lispeval(x.car),lispeval(y.car))
		  &&equal(lispeval(x.cdr),lispeval(y.cdr));
	  } else {
	      return x.type === y.type && x.value === y.value;
	  }
      }

      //--------------
      //REPL functions
      //--------------
      function readeval (expr, env) {
	  //convert a textual lisp program to an ast and eval it
	  let result =  lispeval(parseAST(tokenize(expr),[]),env);
	  return result;
      }

      function printExpr(expr) {
	  //prints a lisp expression in human readable form
	  if(expr === undefined) {
	      return "&lt;no value&gt;";
	  }
	  if(expr.type == "cons") {
	      let result = "( ";
	      for(let element of generateCons(expr)) {
		  result += printExpr(element) + " ";
	      }
	      return result + ")";	      
	  } else if(expr.type === "lambda"){
	      return "(lambda " + printExpr(expr.args) + " " + printExpr(expr.body) + " )";
	  } else {
	      return expr.value;
	  }
      }

      //-------------------------------
      // Global Environment & Constants
      //-------------------------------
      let globalEnv = {};
      globalEnv["#t"] = {type: "symbol", value: "#t"};
      globalEnv["#f"] = {type: "symbol", value: "#f"};
      globalEnv["()"] = {type: "symbol", value: "()"};
      //---------------------
      // Predefined functions
      //---------------------
//template for c&p:      readeval("(define )",globalEnv);
      readeval("(define (* x y) (cond ((equal? y 1) x) ((< y 1) #f) (#t (+ x (* x (- y 1))))))",globalEnv);
      readeval("(define (> x y) (< y x))",globalEnv);
      readeval("(define (mod x y) (cond ((equal? x y) 0) ((< x y) x) (#t (mod (- x y) y))))",globalEnv);
      readeval("(define (div x y) (define (divhelp x y acc) (cond ((< y 0) #f) ((< x y)  acc) ((equal? x y) (+ acc 1)) ((> x y) (divhelp (- x y) y (+ acc 1))))) (divhelp x y 0))",globalEnv);
      










      
      function testCases() {
	  //misc. regression tests
	  console.log ("expected: 2 actual value: "  + readeval("(car (cdr (cons 1 (cons 2 (cons 3 4)))))", globalEnv).value);
	  readeval("(define x 3)",globalEnv);
	  console.log ("expected: 10 actual value: " + readeval("(+ x x 4)", globalEnv).value);
	  console.log ("expected: #t actual value: " + readeval("(equal? (cons 1 (+ 1 2)) (cons (+ 0 1) 3))", globalEnv).value);
	  console.log ("expected: #t actual value: " + readeval("(cond ((equal? 1 2) #f)((equal? 1 1) #t))", globalEnv).value);
	  console.log ("expected: #t actual value: " + lispeval(lispeval(readeval("#t",globalEnv),globalEnv), globalEnv).value);
	  console.log ("expected: 11 actual value: " + readeval("(((lambda (x) (lambda (y) (+ x y))) 6) 5)", globalEnv).value);
	  readeval("(define (times-2 x) (+ x x))",globalEnv);
	  console.log ("expected: 6 actual value: " + readeval("(times-2 3)", globalEnv).value);
 	  readeval("(define (cadr x) (car (cdr x)))",globalEnv);
	  console.log ("expected: 2 actual value: " + readeval("(cadr (cons 1 (cons 2 ())))", globalEnv).value);
	  readeval("(define (sum x) (cond ((equal? x 0) 0) (#t (+ x (sum (- x 1))))))",globalEnv);
	  console.log ("expected: 120 actual value: " + readeval("(sum 15)", globalEnv).value);
	  console.log ("expected: 10 actual value: " + readeval("(div 250 25)", globalEnv).value);
	  
	  
      }

    </script>
  </body>
</html>

<!--
TODO:
Bugs / Missing features:
- [ ] +, -, < can't be used in higher-order functions. Define + as a function and use primitive-plus as special form?
  - [ ] However, this makes variadic + impossible right now. Implement variadic functions?
- [X] quote is broken?
- [ ] define <=, >=, and, or, if, ...
- [X] printExpr doesn't handle lambda yet
- [ ] function application mutates a lambda's environment permanently
- [?] improve UI
- [X] use cons instead of array

Bonus-features
- (list ...), 
- [X] print conses as lists
- 'quote
- Macros?
- Numbers as functions?
- js-eval?
- Strings?
- macros from Lisp Micro Manual

-->
