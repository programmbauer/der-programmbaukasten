<!doctype html>
<html>
  <head>
    <meta charset="UTF-8"> 
    <title>T1-Lisp</title>
  </head>
  <body onload="">
    <div style="font-family: Courier; font-weight: bold">
      <h2>Welcome to T1-Lisp</h2>
      <div id="output"></div><br>
      <div>
	&gt; <input type="text" id="input" style="border: none; width:600px"><br>
	<button type="button" onclick="run();" style="border-style: solid">Eval!</button>
	<button type="button" onclick="clrscr();" style="border-style: solid">Clear</button>
				       
      </div>
    </div>
    <script>
      "use strict";

      //----------------------
      // Button event handlers
      //----------------------
      function clrscr () {
	  //clears the #output area
	  document.querySelector('#output').innerHTML = '';
      }

      function run() {
	  //event handler, eval's text from the #input field
	  const output = document.querySelector('#output');
	  const input  = document.querySelector('#input');
	  output.innerHTML += "> " + input.value + "<br>";
	  let result = "";
	  try {
	      result = printExpr(readeval(input.value,globalEnv));
	  } catch(e) {
	      result = "Error: " + e;
	  }
	  output.innerHTML += result + "<br>";
	  input.value = "";
      }

      //------------------------------
      // Parsing related stuff
      //------------------------------
      function tokenize(inputString){
	  //insert spaces before and after parentheses, then split at spaces
	  //to get a flat array of tokens
	  const withSpaces = inputString.
		replace(/\(/g, " ( ").
		replace(/\)/g, " ) ").
		replace(/\n/g, " ").
		replace(/\t/g, " ");
	  return withSpaces.split(" ").filter(string=>string.length>0);
      }

      function parseAST(tokens) {
	  //transform the flat array from tokenize() into a hierarchical AST
	  function parseToken(token) {
	      if(token===undefined) {
		  throw "Empty input";
	      } else if(token === "(") {
		  return parseList();
	      } else if  (token.match(/^-?[0-9]+$/) != null) {
		  return {type: "number", value: parseInt(token)};
	      } else if (token.match(/^[a-zA-Z0-9\+\-\*\#\?\<\>\!\&\=]+$/) != null) {
		  return {type: "symbol", value: token};
	      } else {
		  throw "Invalid token: " + token;
	      }
	  }
	
	  function parseList() {
	      let list = NIL;
	      while(true) {
		  token = tokens.shift();
		  if(token === undefined) {
		      throw "Missing ')'";
		  } else if (token === ")") {
		      return list;
		  } else {
		      list = append(list, parseToken(token));
		  }
	      }
	  }
  	  let token = 0;
	  let ast = NIL;
	  token = tokens.shift();
	  if(token === "(") {
	      ast = parseList();
	  } else {
	      ast = parseToken(token);
	  }
	  return ast;
      }

      //----------------------
      // Cons helper functions
      //----------------------
      function append(list, element) {
	  let help = list;
	  if(list === NIL) {
	      return {type: "cons", car: element, cdr: NIL};
	  } else {
	      while(help.cdr != NIL) {
		  if(help.type != "cons") {
		      console.log(help);
		      throw "Append expected a proper list, but found a " + help.type;
		  }
		  help = help.cdr;
	      }
	      help.cdr = {type: "cons", car: element, cdr: NIL};
	      return list;
	  }
      }

      function* generateCons(cons) {
	  if(cons === NIL) {
	      return cons;
	  } else if (cons.type != "cons") {
	      throw "generateCons expected a cons cell, but found a " + cons.type;
	  } else {
	      while(cons.type === "cons") {
		  yield cons.car;
		  cons = cons.cdr;
	      }
	      if(cons != NIL) {
		  yield cons;
	      }
	  }
      }

      function lengthCons(cons) {
	  let n = 0;
	  while(true) {
	      if(cons === NIL) {
		  return n;
	      } else if (cons.type === "cons") {
		  n = n + 1;
		  cons = cons.cdr;
	      } else {
		  throw "lengthCons: not a proper list: " + cons.type;
	      }
	  }
      }

      function nthCons(cons, n) {
	  //gets the nth value from a list, starting with element 0.
	  while(true) {
	      if(n <= 0) {
		  return cons.car;
	      }
	      n = n - 1;
	      cons = cons.cdr;
	  }
      }
      
      //-------------
      // Eval & Apply
      //-------------

      function lispeval (ast,env) {
	  //evaluatest the expression ast (as computed by parseAST) in the environment env

	  //console.log("DEBUG: lispeval");
	  //console.log(ast);
	  //console.log(env);
	  if(ast.type === "cons") {
	      if (ast.car.value === "define") {
		  //this takes care of McCarthy's LABEL rule, as a define'd procedure is
		  //executed in an environment where it's already bound. Much more SICP style.
		  if (ast.cdr.car.type === "symbol") {
		      env[ast.cdr.car.value] = lispeval(ast.cdr.cdr.car,env);
		  } else if (ast.cdr.car.type === "cons") {
		      let spec = ast.cdr.car;
		      let body = ast.cdr.cdr;
		      env[spec.car.value] = {type: "lambda", args: spec.cdr, env: makeEnv(env), body: body};
		  } else {
		      throw "Define expected a symbol or a cons (i.e. function spec), found " + printExpr(ast.cdr.car);
		  }
		  return env.__get(ast.cdr.car.value);
	      } else if (ast.car.value === "primitive-plus") {
		  let a = lispeval(ast.cdr.car, env);
		  let b = lispeval(ast.cdr.cdr.car, env);
		  if (a.type != "number") {
		      throw "Cannot add: " + printExpr(a);
		  }
		  if (b.type != "number") {
		      throw "Cannot add: " + printExpr(b);
		  }
		  let result = a.value+b.value;
		  return {type: "number", value: result};
	      } else if (ast.car.value === "primitive-minus") {
		  let a = lispeval(ast.cdr.car, env);
		  let b = lispeval(ast.cdr.cdr.car, env);
		  if (a.type != "number") {
		      throw "Cannot subtract: " + printExpr(a);
		  }
		  if (b.type != "number") {
		      throw "Cannot subtract: " + printExpr(b);
		  }
		  let result = a.value-b.value;
		  return {type: "number", value: result};
	      } else if (ast.car.value === "primitive-less-than") {
		  let x = lispeval(ast.cdr.car, env).value;
		  let y = lispeval(ast.cdr.cdr.car, env).value;
		  if (x != undefined && y != undefined) {
		      if(x < y) {
			  return(_T);
		      } else {
			  return(_F);
		      }
		  } else {
		      throw "Cannot compare " + x + " and " + y;
		  }
	      } else if (ast.car.value === "quote") {
		  //TODO: add a warning if ast.cdr.cdr is non-empty
		  if(ast.cdr.cdr != NIL) {
		      throw "Quote expects a single argument. Maybe use a list?";
		  }
		  return ast.cdr.car;
	      } else if (ast.car.value === "primitive-car") {
		  let obj = lispeval(ast.cdr.car, env);
		  if (obj === undefined) {
		      throw "Undefined object: " + printExpr(ast.cdr.car);
		  }
		  if(obj.type === "cons") {
		      return obj.car;
		  } else {
		      throw "Car expected a cons cell, found " + printExpr(obj);
		  }
	      } else if (ast.car.value === "primitive-cdr") {
		  let obj = lispeval(ast.cdr.car, env);
		  if (obj === undefined) {
		      throw "Undefined object: " + printExpr(ast.cdr.car);
		  }
		  if(obj.type === "cons") {
		      return obj.cdr;
		  } else {
		      throw "Cdr expected a cons cell, found " + obj;
		  }
	      } else if (ast.car.value === "primitive-cons") {
		  return {type: "cons", car: lispeval(ast.cdr.car,env), cdr: lispeval(ast.cdr.cdr.car,env)};
	      } else if (ast.car.value === "primitive-equal?") {
		  let x = lispeval(ast.cdr.car,env);
		  let y = lispeval(ast.cdr.cdr.car,env);
		  if(equal(x,y,env)) {
		      return _T;
		  } else {
		      return _F;
		  }
	      } else if (ast.car.value === "primitive-atom?") {
		  if (lispeval(ast.cdr.car, env).type === "cons") {
		      return _F;
		  } else {
		      return _T;
		  }
	      } else if (ast.car.value === "primitive-apply") {
		  let fun = lispeval(ast.cdr.car,env);
		  let args = env.__get(ast.cdr.cdr.car.value);
		  return lispapply(fun,args,env, ast.cdr.cdr.car.value);
	      } else if (ast.car.value === "cond") {
		  for(let clause of generateCons(ast.cdr)) {
		      let condition = lispeval(clause.car, env);
		      if(condition.value != "#f") {
			  return lispeval(clause.cdr.car,env);
			  break;
		      }
		  }
		  return NIL;
	      } else if (ast.car.value === "lambda") {
		  return {type: "lambda", args: ast.cdr.car, env: makeEnv(env), body: ast.cdr.cdr};
	      } else if (ast.car.value === "macro") {
		  return {type: "macro",  args: ast.cdr.car, env: makeEnv(env), body: ast.cdr.cdr};
	      } else if (ast.car.value === "error") {
		  throw printExpr(ast.cdr);
	      } else {
		  //Function application
		  let fun = lispeval(ast.car, env);
		  if(fun === undefined) {
		      throw "unknown function: " + ast.car.value;
		  }
		  //console.log("DEBUG: eval(function)");
		  //console.log(fun);

		  //new feature "infix": numbers act as actors that consume messages, making infix arithmetic possible
		  if(fun.type === "number") {
		      let args = NIL;
		      let newfun = lispeval(ast.cdr.car, env);
		      if(newfun.type != "lambda" && newfun.type != "macro") {
			  throw "Numbers cannot receive messages of type: " + newfun.type;
		      }
		      for (let arg of generateCons(ast.cdr.cdr)) {
			  args = append(args,lispeval(arg,env));
		      }
		      return lispapply(newfun,{type: "cons", car: fun, cdr: args}, env, "Actor message " + printExpr(newfun));
		  }
		  //end "infix"
		  //new feature "macros"
		  if (fun.type === "macro") {
		      let args = NIL;
		      for (let arg of generateCons(ast.cdr)) {
			  args = append(args,arg); //<-- difference #1
		      }
		      return lispapply(fun, args, env, "macro " + ast.car.value)
		  }
		  //end "macros"
		  //assume fun to be a lambda, let apply deal with errors
		  if (fun.type === "lambda") {

		      let args = NIL;
		      for (let arg of generateCons(ast.cdr)) {
			  args = append(args,lispeval(arg,env));
		      }
		      return lispapply(fun, args, env, ast.car.value);
		  }
		  throw "Cannot apply type " + fun.type
	      }
	  } else {
	      //the expression is an atom
	      if (ast.type === "number") {
		  return ast;
	      } else if (ast.type === "symbol") {
		  let astValue = env.__get(ast.value);
		  if (astValue === undefined) {
		      throw "Unknown symbol: " + printExpr(ast);
		  }
		  return astValue;
	      } else {
		  throw "Illegal type: " + ast;
	      }
	  }
      }

      function lispapply(fun,args, env, name) {
	  if(lengthCons(args) != lengthCons(fun.args) && nthCons(fun.args, lengthCons(fun.args)-1).value != "&rest") {
	      throw "Wrong number of arguments in "+ name +
		  ". expected " + lengthCons(fun.args) + " got " + lengthCons(args);
	  }
	  let funEnv = makeEnv(fun.env);

	  //new feature "macros"
	  if(fun.type === "macro") {
	      funEnv["__get"] = function(val) { //<-- difference #2
		  if(funEnv[val] != undefined) {
		      return lispeval(funEnv[val],env);
		  } else if (funEnv["__parent"]) {
		      return funEnv["__parent"].__get(val);
		  } else {
		      "Apply: Undefined value: " + val;
		  }
	      }
	  }
	  //end "macros
	  
	  let argshelper = fun.args;
	  while(argshelper != NIL) {
	      if(argshelper.car.type === "symbol" && argshelper.car.value === "&rest") {
		  funEnv[argshelper.car.value] = args;
		  break;
	      }
	      funEnv[argshelper.car.value] = args.car;
	      args = args.cdr;
	      argshelper = argshelper.cdr;
	  }
	  let result = NIL;
	  for(let expr of generateCons(fun.body)){
	      result = lispeval(expr,funEnv);
	  }
	  return result;
	  
      }

      //----------------------------------
      // Helper functions for eval & apply
      //----------------------------------
      function makeEnv (parent) {
	  let env = {__parent: parent};
	  env["__get"] = function(val) {
	      if(env[val] != undefined) {
		  return env[val];
	      } else if (env["__parent"]) {
		  return env["__parent"].__get(val);
	      } else {
		  "MakeEnv: Undefined value: " + val;
	      }
	  }
	  return env;
      }

      function equal(x,y) {
	  if(x.type === "lambda" || x.type === "lambda") {
	      throw "don't compare lambdas";
	  }
	  if(x.type === "cons") {
	      return y.type === "cons" &&
		  equal(x.car,y.car) &&
		  equal(x.cdr,y.cdr);
	  } else {
	      return x.type === y.type && x.value === y.value;
	  }
      }

      //---------------
      // REPL functions
      //---------------
      function readeval (expr, env) {
	  //convert a textual lisp program to an ast and eval it
	  let result =  lispeval(parseAST(tokenize(expr),[]),env);
	  return result;
      }

      function printExpr(expr) {
	  //prints a lisp expression in human readable form
	  if(expr === undefined) {
	      return "&lt;no value&gt;";
	  }
	  if(expr.type == "cons") {
	      let result = "( ";
	      for(let element of generateCons(expr)) {
		  result += printExpr(element) + " ";
	      }
	      return result + ")";	      
	  } else if(expr.type === "lambda"){
	      let body = printExpr(expr.body);
	      return "(lambda " + printExpr(expr.args) + " " + body.substr(1,body.length-2) + ")";
	  } else if(expr.type === "macro"){
	      let body = printExpr(expr.body);
	      return "(macro " + printExpr(expr.args) + " " + body.substr(1,body.length-2) + ")";
	  } else if (expr.value != undefined){
	      return expr.value;
	  } else {
	      throw "Don't know how to print " + expr;
	  }
      }

      //-------------------------------
      // Global Environment & Constants
      //-------------------------------
      let globalEnv = makeEnv(null);
      globalEnv["#t"] = {type: "symbol", value: "#t"};
      globalEnv["#f"] = {type: "symbol", value: "#f"};
      globalEnv["()"] = {type: "symbol", value: "()"};
      globalEnv["quote"] = {type: "symbol", value: "quote"};
      const _T = globalEnv.__get("#t");
      const _F = globalEnv.__get("#f");
      const NIL = globalEnv.__get("()");
      
      //---------------------
      // Predefined functions
      //---------------------
      //template for c&p: readeval("(define )",globalEnv);
      //lisp wrappers for all appropriate primitives
      readeval("(define (+ &rest) (cond ((equal? () &rest) 0) (#t (primitive-plus (car &rest) (apply + (cdr &rest))))))",globalEnv);
      readeval("(define (- &rest) (cond ((equal? () &rest) 0) (#t (primitive-minus (car &rest) (apply - (cdr &rest))))))",globalEnv);
      readeval("(define (< a b) (primitive-less-than a b))",globalEnv);
      readeval("(define (cons a b) (primitive-cons a b))",globalEnv);
      readeval("(define (car a) (primitive-car a))",globalEnv);
      readeval("(define (cdr a) (primitive-cdr a))",globalEnv);
      readeval("(define (atom? a) (primitive-atom? a))",globalEnv);
      readeval("(define (apply fun args) (primitive-apply fun args))",globalEnv);
      readeval("(define (equal? a b) (primitive-equal? a b))",globalEnv);

      //some macros
      readeval("(define if (macro (i t e) (cond (i t) (#t e))))",globalEnv);
      readeval("(define and (macro (p q) (cond (p q) (#t #f))))",globalEnv);
      readeval("(define or (macro (p q) (cond (p p) (#t q))))",globalEnv);
      

      
      //misc. functions
      readeval("(define = equal?)",globalEnv);
      readeval("(define (> x y) (< y x))",globalEnv);
      readeval("(define (>= x y) (or (> x y) (equal? x y)))",globalEnv);
      readeval("(define (<= x y) (or (< x y) (equal? x y)))",globalEnv);
      readeval("(define (* x y) (cond ((equal? y 0) 0) ((< y 1) (* (- 0 x) (- 0 y))) (#t (+ x (* x (- y 1))))))",globalEnv);
      readeval("(define (mod x y) (cond ((equal? x y) 0) ((< x y) x) (#t (mod (- x y) y))))",globalEnv);
      readeval("(define remainder mod)",globalEnv); //TODO: Which name should I keep?
      readeval("(define (div x y) (define (divhelp x y acc) (cond ((equal? y 0) (error div -- Division by zero)) ((< y 0) (error div -- Only positive values for y are supported)) ((< x y)  acc) " +
	       "((>= x y) (divhelp (- x y) y (+ acc 1))))) (divhelp x y 0))",globalEnv);
      readeval("(define (list &rest) &rest)",globalEnv);
      readeval("(define (map f l) (cond ((equal? l ()) ()) (#t (cons (f (car l)) (map f (cdr l))))))", globalEnv);
      readeval("(define (reduce f l init) (cond ((equal? l ()) init) (#t (reduce f (cdr l) (f init (car l))))))", globalEnv);
      readeval("(define (null? l) (equal? l ()))",globalEnv);
      readeval("(define (even? x) (= (mod x 2) 0)))",globalEnv);
      readeval("(define (not x) (if (= x #f) #t #f))",globalEnv);


      //Streams from SICP chapter 3
      readeval("(define delay (macro (exp) (lambda () exp)))",globalEnv);
      readeval("(define cons-stream (macro (a b) (cons a (delay b))))",globalEnv);
      readeval("(define (force delayed-object) (delayed-object))",globalEnv);
      readeval("(define (stream-car stream) (car stream))",globalEnv);
      readeval("(define (stream-cdr stream) (force (cdr stream)))",globalEnv);
      readeval("(define the-empty-stream ())",globalEnv);
      readeval("(define stream-null? null?)",globalEnv);
      readeval("(define (stream-ref s n) (if (= n 0) (stream-car s) (stream-ref (stream-cdr s) (- n 1))))",globalEnv);
      readeval("(define (stream-map proc s) (if (stream-null? s) the-empty-stream (cons-stream (proc (stream-car s)) (stream-map proc (stream-cdr s)))))",globalEnv);
      readeval("(define (stream-for-each proc s)  (if (stream-null? s) (quote done) (begin (proc (stream-car s)) (stream-for-each proc (stream-cdr s)))))",globalEnv);
      //skipped display-stream and display-line for now; need to implement display etc.
      readeval("(define (stream-enumerate-interval low high) (if (> low high) the-empty-stream (cons-stream low (stream-enumerate-interval (+ low 1) high))))",globalEnv);
      readeval("(define (stream-filter pred stream) (cond ((stream-null? stream) the-empty-stream) ((pred (stream-car stream)) (cons-stream (stream-car stream)"+
	       "(stream-filter pred (stream-cdr stream)))) (#t (stream-filter pred (stream-cdr stream)))))",globalEnv); //replaced else with #t, //TODO: add else to cond
      //TODO: Why does this example fail? (stream-car (stream-cdr (stream-filter even? (stream-enumerate-interval 10000 1000000)))) // ANSWER: Because of the recursion in mod -.-
      //skipped memo-proc, need to implement set!
      //skipped stuff
      readeval("(define (integers-starting-from n) (cons-stream n (integers-starting-from (+ n 1))))",globalEnv);

      readeval("(define integers (integers-starting-from 1))",globalEnv);
      readeval("(define (divisible? x y) (= (remainder x y) 0))",globalEnv);
      readeval("(define no-sevens (stream-filter (lambda (x) (not (divisible? x 7))) integers))",globalEnv);
      readeval("(define (sieve stream) (cons-stream (stream-car stream) (sieve (stream-filter (lambda (x) (not (divisible? x (stream-car stream)))) (stream-cdr stream)))))",globalEnv);
      readeval("(define primes (sieve (integers-starting-from 2)))",globalEnv);


      
      //------------------------
      // Tests and related stuff
      //------------------------
      function _test (expr, expected) {
	  let testresult = readeval(expr, globalEnv);
	  let expectedresult = readeval(expected, globalEnv);
	  let message = " //expected: " + printExpr(expectedresult)  + " found: " +  printExpr(testresult);
	  if(equal(testresult,expectedresult)) {
	      message = "OK" + message;
	  } else {
	      message = "!!" + message;
	  }
	  console.log(message);
      }

      
      function testCases() {
	  //misc. regression tests
	  _test("#t",lispeval(lispeval(readeval("#t",globalEnv),globalEnv), globalEnv).value);
	  _test("(car (cdr (cons 1 (cons 2 (cons 3 4)))))", "2");
	  readeval("(define x 3)",globalEnv);
	  _test ("(+ x (+ x 4))", "10");
	  _test("(equal? (cons 1 (+ 1 2)) (cons (+ 0 1) 3))", "#t");
	  _test("(cond ((equal? 1 2) #f)((equal? 1 1) #t))", "#t");
	  _test("(((lambda (x) (lambda (y) (+ x y))) 6) 5)", "11");
	  readeval("(define (times-2 x) (+ x x))",globalEnv);
	  _test("(times-2 3)", "6");
 	  readeval("(define (cadr x) (car (cdr x)))",globalEnv);
	  _test("(cadr (cons 1 (cons 2 ())))","2");
	  //recursion:
	  readeval("(define (sum x) (if (equal? x 0) 0 (+ x (sum (- x 1)))))",globalEnv);
	  _test("(sum 15)", "120");
	  //using predefined scheme functions:
	  _test("(* 100 100)", "10000");
	  _test("(div 250 25)", "10");
	  //recursive fibonacci:
	  readeval("(define (fib n) (cond ((< n 2) n) (#t (+ (fib (- n 1)) (fib (- n 2))))))",globalEnv);
	  _test("(fib 7)","13");
	  _test("(equal? (quote (a b c)) (quote (a b c)))","#t");
	  _test("(equal? (quote (a b c)) (quote (a b)))","#f");
	  //yay, quote works
	  _test("(equal? (map fib (quote (1 2 3))) (quote (1 1 2)))","#t");
	  //factorial using the "poor man's y combinator (W. Byrd):
	  _test("(((lambda (!) (lambda (n) ((! !) n))) (lambda (!) (lambda (n) (cond ((equal? n 0) 1) (#t (* n ((! !) (- n 1)))))))) 5)","120");
	  _test("(map atom? (quote (1 (2 3) hi (bye))))","(list #t #f #t #f)");
	  _test("(reduce + (list 1 2 3 4 5) 0)","15");
	  //this wouldn't be possible without macros
	  _test("(if #t 1 (div 1 0))","1");
	  _test("(stream-ref no-sevens 100)","117");
	  _test("(stream-ref primes 50)","233");
      }

    </script>
  </body>
</html>

<!--
TODO:
Bugs / Missing features:
- [X] +, -, < can't be used in higher-order functions. Define + as a function and use primitive-plus as special form?
  - [X] However, this makes variadic + impossible right now. Implement variadic functions?
- [X] quote is broken?
- [X] define <=, >=, and, or, if, ...
  - [X] Macros?
- [X] printExpr doesn't handle lambda yet (fixed to remove () around body)
- [X] function application mutates a lambda's environment permanently
- [?] improve UI
- [X] use cons instead of array
- [ ] Tail Call Elimination 
  -[ ] => implement queue of unevaluated lisp expressions, turn js-recursion into loop
- [X] fix equal? for quote and lambda. and fix it again. fix quote.
- [X] add (map f l)

Bonus-features
- [X] (list ...), 
- [X] print conses as lists
- 'quote
- unquote, splicing
- [X] Numbers as functions?
- js-eval?
- Strings?
- macros & definitions from Lisp Micro Manual
- make memory-management explicit by using a stack of environments? 
  (bad idea, because new environments could use any existing one as their parent)
- set! to change value in env higher up the chain
- display, ...


-->
