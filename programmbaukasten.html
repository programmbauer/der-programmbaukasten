<!doctype html>
<html>
  <head>
    <meta charset="UTF-8"> 
    <title>T1-Lisp</title>
  </head>
  <body onload="">
    <div style="font-family: Courier; font-weight: bold">
      <h2>Welcome to T1-Lisp</h2>
      <div id="output"></div><br>
      <div>
	&gt; <input type="text" id="input" style="border: none; width:300px"></input><br>
	<button type="button" onclick="run();" style="border-style: solid">Eval!</button>
	<button type="button" onclick="clrscr();" style="border-style: solid">Clear</button>
				       
      </div>
    </div>
    <script>
      "use strict";

      function clrscr () {
	  //clears the #output area
	  document.querySelector('#output').innerHTML = '';
      }

      function run() {
	  //event handler, eval's text from the #input field
	  const output = document.querySelector('#output');
	  const input  = document.querySelector('#input');
	  output.innerHTML += "> " + input.value + "<br>";
	  let result = "";
	  try {
	      result = printExpr(readeval(input.value,globalEnv));
	  } catch(e) {
	      result = "Error: " + e;
	  }
	  output.innerHTML += result + "<br>";
	  input.value = "";
      }

      function tokenize(inputString){
	  //insert spaces before and after parentheses, then split at spaces
	  //to get a flat array of tokens
	  const withSpaces = inputString.
		replace(/\(/g, " ( ").
		replace(/\)/g, " ) ").
		replace(/\n/g, " ").
		replace(/\t/g, " ");
	  return withSpaces.split(" ");
      }

      function parseAST(tokens, ast) {
	  //transform the flat array from tokenize() into a hierarchical AST
	  let token = 0;
	  token = tokens.shift();
	  if(token === undefined) {
	      return ast.pop() || []; //[] to catch empty input
	  }
	  if(!typeof token === "string") {
	      throw "Error: Token is not a string " + token;
	  }
	  if(token === "") {
	      return parseAST(tokens, ast);
	  }
	  else if (token === "(") {
	      ast.push(parseAST(tokens, []));
	      return parseAST(tokens, ast);
	  } else if (token === ")") {
	      return ast;
	  } else if (token.match(/^[0-9]+$/) != null) {
	      ast.push({type: "number", value: parseInt(token)});
	      return parseAST(tokens, ast);
	  } else if (token.match(/^[a-zA-Z0-9\+\-\*\#\?\<\>]+$/) != null) {
	      ast.push({type: "symbol", value: token});
	      return parseAST(tokens, ast);
	  } else {
	      throw "Error: no matching case found for " + token;
	  }
      }
      
      function lispeval (ast,env) {
	  //evaluatest the expression ast (as computed by parseAST) in the environment env
	  if(Array.isArray(ast)) {
	      //if the expr is a list
	      if(ast.length === 0) {
		  return globalEnv["()"];
	      }
	      let car = ast[0];
	      if (car.value === "define") {
		  //this takes care of McCarthy's LABEL rule, as a define'd procedure is
		  //executed in an environment where it's already bound. Much more SICP style.
		  if (ast[1].type === "symbol") {
		      env[ast[1].value] = lispeval(ast[2],env);
		  } else if (Array.isArray(ast[1])) {
		      let spec = ast[1];
		      let body = ast.slice(2);
		      env[spec[0].value] = {type: "lambda", args: spec.slice(1), env: {__parent : env}, body: body};
		  }
	      } else if (car.value === "+") {
		  let result = 0;
		  for(let element of ast.slice(1)) {
		      let obj = lispeval(element, env);
		      if (obj.type == "number") {
			  result += obj.value;
		      } else {
			  throw "Cannot add: " + obj;
		      }
		  }
		  return {type: "number", value: result};
	      } else if (car.value === "-") {
		  let result = lispeval(ast[1],env).value;
		  for(let element of ast.slice(2)) {
		      let obj = lispeval(element, env);
		      if (obj.type == "number") {
			  result -= obj.value;
		      } else {
			  throw "Cannot add: " + obj;
		      }
		  }
		  return {type: "number", value: result};
	      } else if (car.value === "<") {
		  let x = lispeval(ast[1], env).value;
		  let y = lispeval(ast[2], env).value;
		  if (x != undefined && y != undefined) {
		      if(x < y) {
			  return(globalEnv["#t"]);
		      } else {
			  return(globalEnv["#f"]);
		      }
		  } else {
		      throw "cannot compare " + x + " and " + y;
		  }
	      } else if (car.value === "quote") {
		  ast.pop();
		  return ast;
	      } else if (car.value === "car") {
		  let obj = lispeval(ast[1], env);
		  if(obj.type === "cons") {
		      return obj.car;
		  } else {
		      throw "Not a cons cell: " + obj;
		  }
	      } else if (car.value === "cdr") {
		  let obj = lispeval(ast[1], env);
		  if(obj.type === "cons") {
		      return obj.cdr;
		  } else {
		      throw "Not a cons cell: " + obj;
		  }
	      } else if (car.value === "cons") {
		  return {type: "cons", car: lispeval(ast[1],env), cdr: lispeval(ast[2],env)};
	      } else if (car.value === "equal?") {
		  if(equal(ast[1],ast[2], env)) {
		      return globalEnv["#t"];
		  } else {
		      return globalEnv["#f"];
		  }
	      } else if (car.value === "atom?") {
		  if (lispeval(ast[1], env).type === "cons") {
		      return globalEnv["#f"];
		  } else {
		      return globalEnv["#t"];
		  }
	      } else if (car.value === "cond") {
		  for(let clause of ast.slice(1)) {
		      let condition = lispeval(clause[0], env);
		      if(condition.value != "#f") {
			  return lispeval(clause[1],env);
			  break;
		      }
		  }
		  return globalEnv["()"];
	      } else if (car.value === "lambda") {
		  return {type: "lambda", args: ast[1], env: {__parent : env}, body: ast.slice(2)};
	      } else {
		  //Function application
		  let fun = lispeval(car, env);
		  if(fun === undefined) {
		      throw "unknown function: " + car.value;
		  }
		  //console.log("DEBUG: eval(function)");
		  //console.log(fun);
		  let args = [];
		  for (let arg of ast.slice(1)) {
		      args.push(lispeval(arg,env));
		  }
		  if(fun.type != "lambda") {
		      throw "cannot apply: " + fun.type + " " + fun.value;
		  }
		  if(args.length != fun.args.length) {
		      throw "wrong number of arguments. expected " +
			  fun.args.length + " got " + args.length;
		  }
		  for(let i = 0; i < args.length; i++) {
		      fun.env[fun.args[i].value] = args[i];
		  }
		  let result = globalEnv["()"];
		  for(let expr of fun.body){
		      result = lispeval(expr,fun.env);
		  }
		  return result;
	      }
	  } else {
	      if (ast.type === "number") {
		  return ast;
	      } else if (ast.type === "symbol") {
		  let astValue = getVal(ast.value,env);
		  //if (astValue === undefined) {
		  //    throw "Undefined value: " + ast.value;
		  //} else {
		      return astValue;
		  //}
	      } else {
		  throw "illegal type: " + ast;
	      }
	  }
      }

      function getVal(val,env) {
	  //console.log("DEBUG: getVal");
	  //console.log(val);
	  //console.log(env);
	  if(env[val] != undefined) {
	      return env[val];
	  } else if (env["__parent"]) {
	      return getVal(val,env["__parent"]);
	  } else {
	      "Undefined value: " + val;
	  }
      }

      function equal(quotex,quotey, env) {
	  //checks if quotex and quotey evaluate to the same value
	  let x = lispeval(quotex,env);
	  let y = lispeval(quotey,env);
	  if(x.type === "cons") {
	      return equal(lispeval(x.car),lispeval(y.car))
		  &&equal(lispeval(x.cdr),lispeval(y.cdr));
	  } else {
	      return x.type === y.type && x.value === y.value;
	  }
      }

      //--------------
      //REPL functions
      //--------------
      function readeval (expr, env) {
	  //convert a textual lisp program to an ast and eval it
	  let result =  lispeval(parseAST(tokenize(expr),[]),env);
	  return result;
      }

      function printExpr(expr) {
	  //prints a lisp expression in human readable form
	  if(expr === undefined) {
	      return "&lt;no value&gt;";
	  }
	  if(expr.type == "cons") {
	      return "(cons " + printExpr(expr.car) +
		  " " + printExpr(expr.cdr) + ")";
	  } else {
	      return expr.value;
	  }
      }

      //-------------------------------
      // Global Environment & Constants
      //-------------------------------
      let globalEnv = {};
      globalEnv["#t"] = {type: "symbol", value: "#t"};
      globalEnv["#f"] = {type: "symbol", value: "#f"};
      globalEnv["()"] = {type: "symbol", value: "()"};
      //---------------------
      // Predefined functions
      //---------------------
//template for c&p:      readeval("(define )",globalEnv);
      readeval("(define (* x y) (cond ((equal? y 1) x) ((< y 1) #f) (#t (+ x (* x (- y 1))))))",globalEnv);
      readeval("(define (> x y) (< y x))",globalEnv);
      readeval("(define (mod x y) (cond ((equal? x y) 0) ((< x y) x) (#t (mod (- x y) y))))",globalEnv);
      readeval("(define (div x y) (define (divhelp x y acc) (cond ((< y 0) #f) ((< x y)  acc) ((equal? x y) (+ acc 1)) ((> x y) (divhelp (- x y) y (+ acc 1))))) (divhelp x y 0))",globalEnv);
      










      
      function testCases() {
	  //misc. regression tests
	  console.log ("expected: 2 actual value: "  + readeval("(car (cdr (cons 1 (cons 2 (cons 3 4)))))", globalEnv).value);
	  readeval("(define x 3)",globalEnv);
	  console.log ("expected: 10 actual value: " + readeval("(+ x x 4)", globalEnv).value);
	  console.log ("expected: #t actual value: " + readeval("(equal? (cons 1 (+ 1 2)) (cons (+ 0 1) 3))", globalEnv).value);
	  console.log ("expected: #t actual value: " + readeval("(cond ((equal? 1 2) #f)((equal? 1 1) #t))", globalEnv).value);
	  console.log ("expected: #t actual value: " + lispeval(lispeval(readeval("#t",globalEnv),globalEnv), globalEnv).value);
	  console.log ("expected: 11 actual value: " + readeval("(((lambda (x) (lambda (y) (+ x y))) 6) 5)", globalEnv).value);
	  readeval("(define (times-2 x) (+ x x))",globalEnv);
	  console.log ("expected: 6 actual value: " + readeval("(times-2 3)", globalEnv).value);
 	  readeval("(define (cadr x) (car (cdr x)))",globalEnv);
	  console.log ("expected: 2 actual value: " + readeval("(cadr (cons 1 (cons 2 ())))", globalEnv).value);
	  readeval("(define (sum x) (cond ((equal? x 0) 0) (#t (+ x (sum (- x 1))))))",globalEnv);
	  console.log ("expected: 120 actual value: " + readeval("(sum 15)", globalEnv).value);
	  console.log ("expected: 10 actual value: " + readeval("(div 250 25)", globalEnv).value);
	  
	  
      }

    </script>
  </body>
</html>

<!--
TODO:
Bugs / Missing features:
- +, -, < can't be used in higher-order functions. Define + as a function and use primitive-plus as special form?
  - However, this makes variadic + impossible right now. Implement variadic functions?
- quote is broken?
- define <=, >=, and, or, if, ...
- printExpr doesn't handle lambda yet
- function application mutates a lambda's environment permanently
- improve UI

Bonus-features
- (list ...), print conses as lists
- 'quote
- Macros?
- Numbers as functions?
- js-eval?
- Strings?
- macros from Lisp Micro Manual

-->
